;====================================================================
; Main.asm file generated by New Project wizard
;
; Created:   åÇÑÔäÈå ÝæÑíå 3 2021
; Processor: 80C51
; Compiler:  ASEM-51 (Proteus)
;====================================================================

$NOMOD51
$INCLUDE (8051.MCU)

;====================================================================
; DEFINITIONS
;====================================================================

;====================================================================
; VARIABLES
;====================================================================

;====================================================================
; RESET and INTERRUPT VECTORS
;====================================================================
ORG 0000H
JMP MAIN

; ISR
ORG 0003H
CLR P3.1 ; Disable interrupt
CLR EA ; No interrupt will be acknowledged
CLR EX0 ; Disable external interrupt0
CALL DETECTION
SITUATION0: CJNE R0, #000H, SITUATION1 ; Situation 0 = wait for user to push PC
        PC_CLICK: CJNE R1, #010H, WRONG_CLICK_1 ; Any pushed key will be wrong except PC
			MOV R0, #001H ; Move to status 1
			SETB EA ; Enable interrupt individually
			SETB EX0 ; Enable external interrupt0
			SETB P3.1 ; Enable interrupt
			RETI
        WRONG_CLICK_1:
			MOV R0, #000H ; Stay in status 0
			SETB EA ; Enable interrupt individually
			SETB EX0 ; Enable external interrupt0
			SETB P3.1 ; Enable interrupt
			RETI
SITUATION1: CJNE R0, #001H, SITUATION2 ; Situation 1 = wait for user to enter higher part of start address
        NUMBER_CLICK1: JNB P3.3, WRONG_CLICK2 ; Any pushed will be wrong if it is not a number
			MOV R0, #002H ; Move to status 2
			SETB EA ; Enable interrupt individually
			SETB EX0 ; Enable external interrupt0
			SETB P3.1 ; Enable interrupt
			RETI
        WRONG_CLICK2:
			MOV R0, #001H ; Stay in status 1
			SETB EA ; Enable interrupt individually
			SETB EX0 ; Enable external interrupt0
			SETB P3.1 ; Enable interrupt
			RETI 
SITUATION2: CJNE R0, #002H, SITUATION3 ; Situation 2 = wait for user to enter lower part of start address
        NUMBER_CLICK2: JNB P3.3, WRONG_CLICK3 ; Any pushed will be wrong if it is not a number
			MOV R0, #003H ; Move to status 3
			SETB EA ; Enable interrupt individually
			SETB EX0 ; Enable external interrupt0
			SETB P3.1 ; Enable interrupt
			RETI
		WRONG_CLICK3:
			MOV R0, #002H ; Stay in status 2
			SETB EA ; Enable interrupt individually
			SETB EX0 ; Enable external interrupt0
			SETB P3.1 ; Enable interrupt
			RETI 
SITUATION3: CJNE R0, #003H, SITUATION4 ; Situation 3 = the address is entered and the user should enter EXE
		EXE_CLICK1: CJNE R1, #0D0H, WRONG_CLICK4 ; Any pushed key will be wrong except EXE
			MOV R0, #004H ; Move to status 4
			SETB EA ; Enable interrupt individually
			SETB EX0 ; Enable external interrupt0
			SETB P3.1 ; Enable interrupt
			RETI
		WRONG_CLICK4: 
			MOV R0, #003H ; Stay in status 3
			SETB EA ; Enable interrupt individually
			SETB EX0 ; Enable external interrupt0
			SETB P3.1 ; Enable interrupt
			RETI 
SITUATION4: CJNE R0, #004H, SITUATION5 ; Situation 4 = address is sent to controller and now it is time to enter higher part of data which you want to send to that mempry address
		NUMBER_CLICK3: JNB P3.3, WRONG_CLICK5 ; Any pushed will be wrong if it is not a number
			MOV R0, #005H ; Move to status 5
			SETB EA ; Enable interrupt individually
			SETB EX0 ; Enable external interrupt0
			SETB P3.1 ; Enable interrupt
			RETI
		WRONG_CLICK5:
			MOV R0, #004H ; Stay in status 4
			SETB EA ; Enable interrupt individually
			SETB EX0 ; Enable external interrupt0
			SETB P3.1 ; Enable interrupt
			RETI 
SITUATION5: CJNE R0, #005H, SITUATION6 ; Situation 5 = address is sent to controller and now it is time to enter lower part of data which you want to send to that mempry address
		NUMBER_CLICK4: JNB P3.3, WRONG_CLICK6 ; Any pushed will be wrong if it is not a number
			MOV R0, #006H ; Move to status 6
			SETB EA ; Enable interrupt individually
			SETB EX0 ; Enable external interrupt0
			SETB P3.1 ; Enable interrupt
			RETI
		WRONG_CLICK6:
			MOV R0, #005H ; Stay in status 5
			SETB EA ; Enable interrupt individually
			SETB EX0 ; Enable external interrupt0
			SETB P3.1 ; Enable interrupt
			RETI 
SITUATION6: CJNE R0, #006H, SITUATION7 ; Situation 6 = data is sent to choosen memory address and user must click on EXE
		EXE_CLICK2: CJNE R1, #0D0H, WRONG_CLICK7 ; Any pushed key will be wrong except EXE
			MOV R0, #007H ; Move to status 7
			SETB EA ; Enable interrupt individually
			SETB EX0 ; Enable external interrupt0
			SETB P3.1 ; Enable interrupt
			RETI
		WRONG_CLICK7: 
			MOV R0, #006H ; Stay in status 6
			SETB EA ; Enable interrupt individually
			SETB EX0 ; Enable external interrupt0
			SETB P3.1 ; Enable interrupt
			RETI 
SITUATION7: CJNE R0, #007H, SITUATION8 ; Situation 7 = wait for user to enter higher part of the next address
		NUMBER_CLICK5: JNB P3.3, UP ; Check the next address if it is not a number
			MOV R0, #008H ; Move to status 8
			SETB EA ; Enable interrupt individually
			SETB EX0 ; Enable external interrupt0
			SETB P3.1 ; Enable interrupt
			RETI
		UP: CJNE R1, #050H, DOWN ;  Check the previous address if it is not next
			
			MOV R0, #004H ; Move to status 4
			SETB EA ; Enable interrupt individually
			SETB EX0 ; Enable external interrupt0
			SETB P3.1 ; Enable interrupt
			RETI
		DOWN: CJNE R1, #070H, FINISH_CLICK ;  Check END click if it is not minus
			
			MOV R0, #004H ; Move to status 4
			SETB EA ; Enable interrupt individually
			SETB EX0 ; Enable external interrupt0
			SETB P3.1 ; Enable interrupt
			RETI
	        FINISH_CLICK: CJNE R1, #0F0H, WRONG_CLICK8 ; Other keys are wrong if they are not + or- or number or END
			MOV R0, #009H ; Move to running situation
			RETI
		WRONG_CLICK8:
			MOV R0, #007H ; Stay in status 7
			SETB EA ; Enable interrupt individually
			SETB EX0 ; Enable external interrupt0
			SETB P3.1 ; Enable interrupt
			RETI 
SITUATION8: ; Situation 8 = wait for user to enter lower part of the next address
		NUMBER_CLICK6: JNB P3.3, WRONG_CLICK8 ; Any pushed will be wrong if it is not a number
			MOV R0, #003H ; Move to status 3
			SETB EA ; Enable interrupt individually
			SETB EX0 ; Enable external interrupt0
			SETB P3.1 ; Enable interrupt
			RETI
		WRONG_CLICK9:
			MOV R0, #008H ; Stay in status 8
			SETB EA ; Enable interrupt individually
			SETB EX0 ; Enable external interrupt0
			SETB P3.1 ; Enable interrupt
			RETI 
RETI
 
 
 


ORG 04FFH
MAIN:
        MOV P3, #00FH ; Clear rows of keyboard
        SETB IT0 ; Falling edge interrupt
        CLR EX1 ; Disable external interrupt 1
        MOV R0, #000H ; R0 is a status register and 00 is equal to start and waiting for pc
        MOV R1, #000H ; R1 is a value register whivh we store the value of recent pushed key of key boards in it
	MOV R2, #000H ; R2 is an address register which contain address of RAM we want to write in it
	MOV R3, #000H ; R3 is a data register that contain the value we want to write to memory
	MOV P1, #000H ; Initial value of 00 is shown on 7SEG
        CLR P3.3 ; P3.3 is used as a flag to check wheter the last clicked key was a number or not. if it is one, recenet key was number
        SETB EA ; Enable interrupt individually
        SETB EX0 ; Enable external interrupt0
        STATUS0: CJNE R0, #001H, STATUS0 ; Status 1 will happen only if user push PC button
        STATUS1: CJNE R0, #002H, STATUS1 ; Stay in Status 1 until user clicks on a number
	    MOV B, #010H
	    MOV A, R1
	    MUL AB ; Multiplying R1 by 16 is equal to shifting R1 4bits leftward 
	    MOV R2, A ; Shifted value of R1 is placed in address register
	STATUS2: CJNE R0, #003H, STATUS2 ; Stay in status2 until user clicks a number
	    
	    MOV A, R1
	    ADD A, R2 ; Address is complete
	    MOV R2, A
	    MOV R4, A ; in running procces , PC will be start from the starting addres and for now we send the starting address to R4 and after that in run part we move it to r1 which will be our program counter in run part 
	    MOV P1, A ; Show starting address in 7seg
	    CALL DELAY ; shwo on 7seg for a short time
	    MOV P1, #000H ; show 00 on 7seg again
	STATUS3: CJNE R0, #004H, STATUS3 ; Stay in status 3 until user push EXE
	STATUS4: CJNE R0, #005H, STATUS4 ; Stay in status4 until user enter a number
	    MOV B, #010H
	    MOV A, R1
	    MUL AB ;  Multiplying R1 by 16 is equal to shifting R1 4bits leftward 
	    MOV R3, A ; Shifted value of R1 is placed in data register
	STATUS5: CJNE R0, #006H, STATUS5 ; Stay in status 5 until user enter a number
	    MOV A, R1
	    ADD A, R3 ; Data is complete
	    MOV R3, A
	    MOV P1, A ; Show the data in 7seg
	    CALL DELAY ; shwo on 7seg for a short time
	    MOV P1, #000H ; show 00 on 7seg again
	STATUS6: CJNE R0, #007H, STATUS6 ; Stay in status 6 until user click on EXE
	    MOV A, R2
	    MOV R0, A
	    MOV A, R3
	    MOV @R0, A ; Send the value of data register to memory location pointed by address register
	    MOV  R0, #007H 
	STATUS7: 
	    SUB_STATUS_1: CJNE R0, #008H, SUB_STATUS_2
		  MOV B, #010H
		  MOV A, R1
		  MUL AB ;  Multiplying R1 by 16 is equal to shifting R1 4bits leftward 
		  MOV R2, A ; Shifted value of R1 is placed in address register
		  JMP STATUS8
	    SUB_STATUS_2: CJNE R0, #004H, SUB_STATUS_3
		  NEXT_LOCATION: CJNE R1, #050H, PREV_LOCATION
			MOV A, R2
			CLR C
			ADD A, #001H ; Increase address register
			MOV R2, A
			MOV P1, R2 ; Show current address on7seg
			CALL DELAY ; keep showing for a while
			MOV P1, #000H ; show 00 on 7seg
			JMP STATUS4 ; Go to situation that user should enter data
		  PREV_LOCATION:
			DEC R2 ; Decrease address register
			MOV P1, R2 ; Show current address on7seg
			CALL DELAY ; keep showing for a while
			MOV P1, #000H ; show 00 on 7seg
			JMP STATUS4 ; Go to situation that user should enter data
	    SUB_STATUS_3: CJNE R0, #009H, SUB_STATUS_4
		 JMP RUN
	    SUB_STATUS_4: JMP STATUS7
		
	     
	 STATUS8: CJNE R0, #003H, STATUS8; Stay in status 8 until user enter number
	       MOV A, R1
	       ADD A, R2 ; Address is complete
	       MOV R2, A
	       MOV P1, A ;  Show current address in 7seg
	       CALL DELAY ; keep showing for a while
	       MOV P1, #000H
	       JMP STATUS3 ; Go to situation that user should enter EXE
	 
	 ;This part run the written code in the memory
	 RUN:
	    MOV A, R4
	    MOV R1, A; In this part R1 works as Program counter
	    MOV R4,  #000H ; In this part R4 register is used  to contain the value of memory location shown by r4
	    MOV R3,  #000H ; In this part R3 is used as stack
	    ;MOV R2,  #000H ; In this part R2 is used as accumulator
	 DECODE_EXECUTE:
	    MOV 0FFH, A
	    MOV A, @R1 ; Move the value of memory pointed by R4 to R1 register in order to decode it in Dictionary subroutine
	    MOV R4, A
	    MOV A, 0FFH
	    CALL DICTIONARY ; Decode and execute the opcode which is in R1
	 JMP DECODE_EXECUTE
JMP MAIN



; Subroutine for detecting the key
DETECTION:
        COLUMN_ONE: JB P2.0, COLUMN_TWO ; If P2.0 is high the key is not from the first column of left key board
                ; The key is from the first column
                ZERO:
                        CPL P3.4 ; Set the first row of key board
                        JNB P2.0, EIGHT ; If P2.0 is low after setting P3.4 the key is not 0
                        MOV R1, #000H ; the key is 0
                        CPL P3.4 ; Clear the first row of key boards
                        SETB P3.3 ; The key is a number
                        RET
                EIGHT:
                        CPL P3.4 ; Clear the first row of key board
                        CPL P3.5 ; Set the first row of key board
                        JNB P2.0, START_PC ; If P2.0 is low after setting P3.5 the key is not 8
                        MOV R1, #008H ; the key is 8
                        CPL P3.5 ; Clear the second row of key boards
                        SETB P3.3 ; The key is a number
                        RET
                START_PC:
                        CPL P3.5 ; Clear the second row of key board
                        CPL P3.6 ; Set the third row of key board
                        JNB P2.0, F1 ; If P2.0 is low after setting P3.6 the key is not PC
                        MOV R1, #010H ; the key is PC
                        CPL P3.6 ; Clear the third row of key boards
                        CLR P3.3 ; The key is not a number
                        RET
                F1:
                        MOV R1, #020H ; The key is F1
                        CLR P3.3 ; The key is not a number
                        RET
        COLUMN_TWO: JB P2.1, COLUMN_THREE ; If P2.1 is high the key is not from the second column of left key board
                ; The key is from the second column
                ONE:
                        CPL P3.4 ; Set the first row of key board
                        JNB P2.1, NINE ; If P2.1 is low after setting P3.4 the key is not 1
                        MOV R1, #001H ; the key is 1
                        CPL P3.4 ; Clear the first row of key boards
                        SETB P3.3 ; The key is a number
                        RET
                NINE:
                        CPL P3.4 ; Clear the first row of key board
                        CPL P3.5 ; Set the first row of key board
                        JNB P2.1, ADR ; If P2.1 is low after setting P3.5 the key is not 9
                        MOV R1, #009H ; the key is 9
                        CPL P3.5 ; Clear the second row of key boards
                        SETB P3.3 ; The key is a number
                        RET
                ADR:
                        CPL P3.5 ; Clear the second row of key board
                        CPL P3.6 ; Set the third row of key board
                        JNB P2.1, F2 ; If P2.1 is low after setting P3.6 the key is not ADR
                        MOV R1, #030H ; the key is ADR
                        CPL P3.6 ; Clear the third row of key boards
                        CLR P3.3 ; The key is not a number
                        RET
                F2:
                        MOV R1, #040H ; The key is F1
                        CLR P3.3 ; The key is not a number
                        RET
        COLUMN_THREE: JB P2.2, COLUMN_FOUR ; If P2.2 is high the key is not from the third column of left key board
                ; The key is from the third column
                TWO:
						CPL P3.4 ; Set the first row of key board
						JNB P2.2, AA ; If P2.2 is low after setting P3.4 the key is not 2
                        MOV R1, #002H ; the key is 2
                        CPL P3.4 ; Clear the first row of key boards
                        SETB P3.3 ; The key is a number
                        RET
                AA:
                        CPL P3.4 ; Clear the first row of key board
                        CPL P3.5 ; Set the first row of key board
                        JNB P2.2, PLUS ; If P2.2 is low after setting P3.5 the key is not A
                        MOV R1, #00AH ; the key is A
                        CPL P3.5 ; Clear the second row of key boards
                        SETB P3.3 ; The key is a number
                        RET
                PLUS:
                        CPL P3.5 ; Clear the second row of key board
                        CPL P3.6 ; Set the third row of key board
                        JNB P2.2, F3 ; If P2.2 is low after setting P3.6 the key is not PLUS
                        MOV R1, #050H ; the key is PLUS
                        CPL P3.6 ; Clear the third row of key boards
                        CLR P3.3 ; The key is not a number
                        RET
                F3:
                        MOV R1, #060H ; The key is F3
                        CLR P3.3 ; The key is not a number
                        RET
        COLUMN_FOUR: JB P2.3, COLUMN_FIVE ; If P2.3 is high the key is not from the fourth column of left key board
                ; The key is from the fourth column
                THREE:
                        CPL P3.4 ; Set the first row of key board
                        JNB P2.3, BB ; If P2.3 is low after setting P3.4 the key is not 3
                        MOV R1, #003H ; the key is 3
                        CPL P3.4 ; Clear the first row of key boards
                        SETB P3.3 ; The key is a number
                        RET
                BB:
                        CPL P3.4 ; Clear the first row of key board
                        CPL P3.5 ; Set the first row of key board
                        JNB P2.3, MINUS ; If P2.3 is low after setting P3.5 the key is not B
                        MOV R1, #00BH ; the key is B
                        CPL P3.5 ; Clear the second row of key boards
                        SETB P3.3 ; The key is a number
                        RET
                MINUS:
                        CPL P3.5 ; Clear the second row of key board
                        CPL P3.6 ; Set the third row of key board
                        JNB P2.3, F4 ; If P2.3 is low after setting P3.6 the key is not MINUS
                        MOV R1, #070H ; the key is MINUS
                        CPL P3.6 ; Clear the third row of key boards
                        CLR P3.3 ; The key is not a number
                        RET
                F4:
                        MOV R1, #080H ; The key is F4
                        CLR P3.3 ; The key is not a number
                        RET
        COLUMN_FIVE: JB P2.4, COLUMN_SIX ; If P2.4 is high the key is not from the first column of right key board
                ; The key is from the fifth column
                FOUR:
                        CPL P3.4 ; Set the first row of key board
                        JNB P2.4, CC ; If P2.4 is low after setting P3.4 the key is not 4
                        MOV R1, #004H ; the key is 4
                        CPL P3.4 ; Clear the first row of key boards
                        SETB P3.3 ; The key is a number
                        RET
                CC:
                        CPL P3.4 ; Clear the first row of key board
                        CPL P3.5 ; Set the first row of key board
                        JNB P2.4, DATAA ; If P2.4 is low after setting P3.5 the key is not C
                        MOV R1, #00CH ; the key is C
                        CPL P3.5 ; Clear the second row of key boards
                        SETB P3.3 ; The key is a number
                        RET
                DATAA:
                        CPL P3.5 ; Clear the second row of key board
                        CPL P3.6 ; Set the third row of key board
                        JNB P2.4, F5 ; If P2.4 is low after setting P3.6 the key is not DATA
                        MOV R1, #090H ; the key is DATA
                        CPL P3.6 ; Clear the third row of key boards
                        CLR P3.3 ; The key is not a number
                        RET
                F5:
                        MOV R1, #0A0H ; The key is F5
                        CLR P3.3 ; The key is not a number
                        RET
        COLUMN_SIX: JB P2.5, COLUMN_SEVEN ; If P2.5 is high the key is not from the second column of right key board
                ; The key is from the sixth column
                FIVE:
                        CPL P3.4 ; Set the first row of key board
                        JNB P2.5, D ; If P2.5 is low after setting P3.4 the key is not 5
                        MOV R1, #005H ; the key is 5
                        CPL P3.4 ; Clear the first row of key boards
                        SETB P3.3 ; The key is a number
                        RET
                D:
                        CPL P3.4 ; Clear the first row of key board
                        CPL P3.5 ; Set the first row of key board
                        JNB P2.5, MODE ; If P2.5 is low after setting P3.5 the key is not D
                        MOV R1, #00DH ; the key is D
                        CPL P3.5 ; Clear the second row of key boards
                        SETB P3.3 ; The key is a number
                        RET
                MODE:
                        CPL P3.5 ; Clear the second row of key board
                        CPL P3.6 ; Set the third row of key board
                        JNB P2.5, F6 ; If P2.5 is low after setting P3.6 the key is not MOD
                        MOV R1, #0B0H ; the key is MOD
                        CPL P3.6 ; Clear the third row of key boards
                        CLR P3.3 ; The key is not a number
                        RET
                F6:
                        MOV R1, #0C0H ; The key is F6
                        CLR P3.3 ; The key is not a number
                        RET
        COLUMN_SEVEN: JB P2.6, COLUMN_EIGHT ; If P2.6 is high the key is not from the third column of right key board
                ; The key is from the seventh column
                SIX:
                        CPL P3.4 ; Set the first row of key board
                        JNB P2.6, E ; If P2.6 is low after setting P3.4 the key is not 6
                        MOV R1, #006H ; the key is 6
                        CPL P3.4 ; Clear the first row of key boards
                        SETB P3.3 ; The key is a number
                        RET
                E:
                        CPL P3.4 ; Clear the first row of key board
                        CPL P3.5 ; Set the first row of key board
                        JNB P2.6, EXE ; If P2.6 is low after setting P3.5 the key is not E
                        MOV R1, #00EH ; the key is E
                        CPL P3.5 ; Clear the second row of key boards
                        SETB P3.3 ; The key is a number
                        RET
                EXE:
                        CPL P3.5 ; Clear the second row of key board
                        CPL P3.6 ; Set the third row of key board
                        JNB P2.6, F7 ; If P2.6 is low after setting P3.6 the key is not EXE
                        MOV R1, #0D0H ; the key is EXE
                        CPL P3.6 ; Clear the third row of key boards
                        CLR P3.3 ; The key is not a number
                        RET
                F7:
                        MOV R1, #0E0H ; The key is F1
                        CLR P3.3 ; The key is not a number
                        RET
        COLUMN_EIGHT:
                ; The key is from the eighths column
                SEVEN:
                        CPL P3.4 ; Set the first row of key board
                        JNB P2.7, F ; If P2.7 is low after setting P3.4 the key is not 7
                        MOV R1, #007H ; the key is 7
                        CPL P3.4 ; Clear the first row of key boards
                        SETB P3.3 ; The key is a number
                        RET
                F:
                        CPL P3.4 ; Clear the first row of key board
                        CPL P3.5 ; Set the first row of key board
                        JNB P2.7, FINISH ; If P2.7 is low after setting P3.5 the key is not F
                        MOV R1, #00FH ; the key is F
                        CPL P3.5 ; Clear the second row of key boards
                        SETB P3.3 ; The key is a number
                        RET
                FINISH:
                        CPL P3.5 ; Clear the second row of key board
                        CPL P3.6 ; Set the third row of key board
                        JNB P2.7, F8 ; If P2.7 is low after setting P3.6 the key is not END
                        MOV R1, #0F0H ; the key is END
                        CPL P3.6 ; Clear the third row of key boards
                        CLR P3.3 ; The key is not a number
                        RET
                F8:
                        MOV R1, #0F1H ; The key is F8
                        CLR P3.3 ; The key is not a number
                        RET


; This subroutine is for decoding and executing the codes in memory
DICTIONARY:
   NOP_MNEMONIC: CJNE R4, #000H, INC_A_MNEMONIC
      MOV P1, A ; Show final result on 7seg
      EXECUTE_END: JMP EXECUTE_END
   RET
   
   INC_A_MNEMONIC: CJNE R4, #004H, INC_R0_MNEMONIC
      INC A ; Increase A
      INC R1 ; PC=PC+1
   RET
   
   INC_R0_MNEMONIC: CJNE R4, #008H, INC_R2_MNEMONIC
      INC R0 ; Increase R0
      INC R1 ; PC=PC+1
   RET
   
   INC_R2_MNEMONIC: CJNE R4, #00AH, INC_R5_MNEMONIC
      INC R2 ; Increase R2
      INC R1 ; PC=PC+1
   RET
   
    INC_R5_MNEMONIC: CJNE R4, #00DH, INC_R6_MNEMONIC
      INC R5 ; Increase R5
      INC R1 ; PC=PC+1
   RET
   
   INC_R6_MNEMONIC: CJNE R4, #00EH, INC_R7_MNEMONIC
      INC R6 ; Increase R6
      INC R1 ; PC=PC+1
   RET
   
   INC_R7_MNEMONIC: CJNE R4, #00FH, ACALL_MNEMONIC
      INC R7 ; Increase R7
      INC R1 ; PC=PC+1
   RET
   
   ACALL_MNEMONIC: CJNE R4, #011H, DEC_A_MNEMONIC
      INC R1 ; PC=PC+1
      INC R1 ; PC=PC+1
      MOV 0FFH, A
      MOV A, R1
      MOV R3, A ; Move next PC value to stack
      DEC R1
      MOV A, @R1 
      MOV R1, A ; Move the next address to PC
      MOV A, 0FFH
   RET
   
   DEC_A_MNEMONIC: CJNE R4, #014H, DEC_R0_MNEMONIC
      DEC A ; Decrease A
      INC R1 ; PC=PC+1
   RET
   
   DEC_R0_MNEMONIC: CJNE R4, #018H, DEC_R2_MNEMONIC
      DEC R0 ; Decrease R0
      INC R1 ; PC=PC+1
   RET
   
   DEC_R2_MNEMONIC: CJNE R4, #01AH, DEC_R5_MNEMONIC
      DEC R2 ; Decrease R2
      INC R1 ; PC=PC+1
   RET
   
   DEC_R5_MNEMONIC: CJNE R4, #01DH, DEC_R6_MNEMONIC
      DEC R5 ; Decrease R5
      INC R1 ; PC=PC+1
   RET
   
   DEC_R6_MNEMONIC: CJNE R4, #01EH, DEC_R7_MNEMONIC
      DEC R6 ; Decrease R6
      INC R1 ; PC=PC+1
   RET
   
   DEC_R7_MNEMONIC: CJNE R4, #01FH, JB_MNEMONIC
      DEC R7 ; Decrease R7
      INC R1 ; PC=PC+1
   RET
   
   JB_MNEMONIC: CJNE R4, #020H, RET_MNEMONIC
      
   RET
   
   RET_MNEMONIC: CJNE R4, #022H, ADD_IMMEDIATE_MNEMONIC
      MOV 0FFH, A
      MOV A, R3
      MOV R1, A ; Move stack to PC
      MOV A, 0FFH
   RET
   
   ADD_IMMEDIATE_MNEMONIC: CJNE R4, #024H, ADD_R0_MNEMONIC
      INC R1 ; PC=PC+1
      MOV 0FFH, A
      MOV A, @R1 
      MOV R4, A ; Move the value in next memory location to R4
      MOV A, 0FFH
      ADD A, R4 ; Add A with the value in the next memory location
      INC R1 ; PC=PC+1
   RET
   
   ADD_R0_MNEMONIC: CJNE R4, #028H, ADD_R2_MNEMONIC
     ADD A, R0 ; Add  A with value of R0
     INC R1 
   RET
   
   ADD_R2_MNEMONIC: CJNE R4, #02AH, ADD_R5_MNEMONIC
     ADD A, R2 ; Add  A with value of R0
     INC R1 
   RET
   
   ADD_R5_MNEMONIC: CJNE R4, #02DH, ADD_R6_MNEMONIC
     ADD A, R5 ; Add  A with value of R5
     INC R1 
   RET
   
   ADD_R6_MNEMONIC: CJNE R4, #02EH, ADD_R7_MNEMONIC
     ADD A, R6 ; Add  A with value of R6
     INC R1 
   RET
   
   ADD_R7_MNEMONIC: CJNE R4, #02FH, JNB_MNEMONIC
     ADD A, R7 ; Add  A with value of R7
     INC R1 
   RET
   
   JNB_MNEMONIC: CJNE R4, #030H, ADDC_IMMIDIATE_MNEMONIC
   
   RET
   
   ADDC_IMMIDIATE_MNEMONIC: CJNE R4, #034H, ADDC_R0_MNEMONIC
      INC R1 ; PC=PC+1
      MOV 0FFH, A
      MOV A, @R1 
      MOV R4, A ; Move the value in next memory location to R4
      MOV A, 0FFH
      ADDC A, R4 ; Add A with the value in the next memory location
      INC R1 ; PC=PC+1
   RET
   
   ADDC_R0_MNEMONIC: CJNE R4, #038H, ADDC_R2_MNEMONIC
      ADDC A, R0 ; Add  A with value of R0
      INC R1
   RET
   
   ADDC_R2_MNEMONIC: CJNE R4, #03AH, ADDC_R5_MNEMONIC
      ADDC A, R2 ; Add  A with value of R2
      INC R1
   RET
   
   ADDC_R5_MNEMONIC: CJNE R4, #03DH, ADDC_R6_MNEMONIC
      ADD A, R5 ; Add  A with value of R5
      INC R1 
   RET
   
   ADDC_R6_MNEMONIC: CJNE R4, #03EH, ADDC_R7_MNEMONIC
      ADD A, R6 ; Add  A with value of R6
      INC R1
   RET
   
   ADDC_R7_MNEMONIC: CJNE R4, #03FH, JZ_MNEMONIC
      ADD A, R7 ; Add  A with value of R7
      INC R1 
   RET
   
   JZ_MNEMONIC: CJNE R4, #060H, JNZ_MNEMONIC
   
   RET
   
   JNZ_MNEMONIC: CJNE R4, #070H, AJMP_MNEMONIC
   
   RET
   
   AJMP_MNEMONIC: CJNE R4, #061H, MOV_A_IMMIDIATE_MNEMONIC
      INC R1 ; PC=PC+1
      MOV 0FFH, A
      MOV A, @R1 
      MOV R1, A ; Move the next address to PC
      MOV A, 0FFH
   RET
   
   MOV_A_IMMIDIATE_MNEMONIC: CJNE R4, #074H, MOV_R0_IMMIDIATE_MNEMONIC
      INC R1 
      MOV A, @R1
      INC R1
   RET
   
   MOV_R0_IMMIDIATE_MNEMONIC: CJNE R4, #078H, MOV_R2_IMMIDIATE_MNEMONIC
      INC R1 
      MOV 0FFH, A
      MOV A, @R1
      MOV R0, A
      MOV A, 0FFH
      INC R1
   RET
   
   MOV_R2_IMMIDIATE_MNEMONIC: CJNE R4, #07AH, MOV_R5_IMMIDIATE_MNEMONIC
      INC R1 
      MOV 0FFH, A
      MOV A, @R1
      MOV R2, A
      MOV A, 0FFH
      INC R1
   RET
   
   MOV_R5_IMMIDIATE_MNEMONIC: CJNE R4, #07DH, MOV_R6_IMMIDIATE_MNEMONIC
      INC R1 
      MOV 0FFH, A
      MOV A, @R1
      MOV R5, A
      MOV A, 0FFH
      INC R1
   RET
   
   MOV_R6_IMMIDIATE_MNEMONIC: CJNE R4, #07EH, MOV_R7_IMMIDIATE_MNEMONIC
      INC R1 
      MOV 0FFH, A
      MOV A, @R1
      MOV R6, A
      MOV A, 0FFH
      INC R1
   RET
   
   MOV_R7_IMMIDIATE_MNEMONIC: CJNE R4, #07FH, SUBB_A_IMMIDIATE_MNEMONIC
      INC R1 
      MOV 0FFH, A
      MOV A, @R1
      MOV R7, A
      MOV A, 0FFH
      INC R1
   RET
   
   SUBB_A_IMMIDIATE_MNEMONIC: CJNE R4, #094H,SUBB_A_R0_MNEMONIC
      INC R1 ; PC=PC+1
      MOV 0FFH, A
      MOV A, @R1 
      MOV R4, A ; Move the value in next memory location to R4
      MOV A, 0FFH
      SUBB  A, R4 ; Subtract A by value which is in next memory location
      INC R1 ; PC=PC+1
   RET
   
   SUBB_A_R0_MNEMONIC: CJNE R4, #098H, SUBB_A_R2_MNEMONIC
      SUBB A, R0 ; Subtract A by value of R0
      INC R1
   RET
   
   SUBB_A_R2_MNEMONIC: CJNE R4, #09AH, SUBB_A_R5_MNEMONIC
      SUBB A, R2 ; Subtract A by value of R2
      INC R1
   RET
   
   SUBB_A_R5_MNEMONIC: CJNE R4, #09DH, SUBB_A_R6_MNEMONIC
      SUBB A, R5 ; Subtract A by value of R5
      INC R1
   RET
   
   SUBB_A_R6_MNEMONIC: CJNE R4, #09EH, SUBB_A_R7_MNEMONIC
      SUBB A, R6 ; Subtract A by value of R6
      INC R1
   RET
   
   SUBB_A_R7_MNEMONIC: CJNE R4, #09FH, CPL_BIT_MNEMONIC
      SUBB A, R7 ; Subtract A by value of R7
      INC R1
   RET
   
   CPL_BIT_MNEMONIC: CJNE R4, #0B2H, CJNE_A_IMMEDIATE_MNEMONIC
   
   RET
   
   CJNE_A_IMMEDIATE_MNEMONIC: CJNE R4, #0B4H, CJNE_R0_IMMEDIATE_MNEMONIC
   
   RET
   
   CJNE_R0_IMMEDIATE_MNEMONIC: CJNE R4, #0B8H, CJNE_R2_IMMEDIATE_MNEMONIC
   
   RET
   
   CJNE_R2_IMMEDIATE_MNEMONIC: CJNE R4, #0BAH, CJNE_R5_IMMEDIATE_MNEMONIC
   
   RET
   
   CJNE_R5_IMMEDIATE_MNEMONIC: CJNE R4, #0BDH, CJNE_R6_IMMEDIATE_MNEMONIC
   
   RET
   
   CJNE_R6_IMMEDIATE_MNEMONIC: CJNE R4, #0BEH, CJNE_R7_IMMEDIATE_MNEMONIC
   
   RET
   
   CJNE_R7_IMMEDIATE_MNEMONIC: CJNE R4, #0BFH, CLR_BIT_MNEMONIC
   
   RET
   
   CLR_BIT_MNEMONIC: CJNE R4, #0C2H, SETB_BIT_MNEMONIC
   
   RET
   
   SETB_BIT_MNEMONIC: CJNE R4, #0D2H, CLR_A_MNEMONIC
   
   RET
   
   CLR_A_MNEMONIC: CJNE R4, #0E4H, MOV_A_R0_MNEMONIC
      MOV A, #000H
      INC R1
   RET
   
   MOV_A_R0_MNEMONIC: CJNE R4, #0E8H, MOV_A_R2_MNEMONIC
      MOV A, R0
      INC R1
   RET
   
   MOV_A_R2_MNEMONIC: CJNE R4, #0EAH, MOV_A_R5_MNEMONIC
      MOV  A, R2
      INC R1
   RET
   
   MOV_A_R5_MNEMONIC: CJNE R4, #0EDH, MOV_A_R6_MNEMONIC
      MOV A, R5
      INC R1
   RET
   
   MOV_A_R6_MNEMONIC: CJNE R4, #0EEH, MOV_A_R7_MNEMONIC
      MOV A, R6
      INC R1
   RET
   
   MOV_A_R7_MNEMONIC: CJNE R4, #0EFH, CPL_A_MNEMONIC
      MOV A, R7
      INC R1
   RET
   
   CPL_A_MNEMONIC: CJNE R4, #0F4H, MOV_R0_A_MNEMONIC
      CPL A
      INC R1
   RET
   
   MOV_R0_A_MNEMONIC: CJNE R4, #0F8H, MOV_R2_A_MNEMONIC
      MOV R0, A
      INC R1
   RET
   
   MOV_R2_A_MNEMONIC: CJNE R4, #0FAH, MOV_R5_A_MNEMONIC
      MOV R2, A
      INC R1
   RET
   
   MOV_R5_A_MNEMONIC: CJNE R4, #0FDH, MOV_R6_A_MNEMONIC
      MOV R5, A
      INC R1
   RET
   
   MOV_R6_A_MNEMONIC: CJNE R4, #0FEH, MOV_R7_A_MNEMONIC
      MOV R6, A
      INC R1
   RET
   
   MOV_R7_A_MNEMONIC: CJNE R4, #0FFH, INVALID_OPCODE
      MOV R7, A
      INC R1
   RET
   
   INVALID_OPCODE:
      MOV P1, #0FFH
      ERROR: JMP ERROR
   RET

; delay  generator subroutine
DELAY:
   MOV 0FEH, #020H ; Following delay will reapeat  31 times
   WAIT2:MOV TMOD, #001H
   MOV TL0, #000H
   MOV TH0, #000H
   SETB TR0
   WAIT1: JNB TF0, WAIT1
   CLR TF0
   CLR TR0
   DJNZ 0FEH, WAIT2
RET
   
   
;====================================================================
      END
